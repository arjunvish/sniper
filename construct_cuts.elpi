pred construct_cuts i: (list term), o: term.
construct_cuts [X | XS] (app [(fun `new_hyp` X1 x\ G x), R]) :- 
    std.assert-ok! (coq.elaborate-ty-skeleton X _ X1) "cut formula illtyped",
    pi x\ decl x N H1 =>
    construct_cuts XS (G x).
construct_cuts [] T.

pred args_to_terms i: (list argument), o: (list term).
args_to_terms [trm X | XS] [X | R] :- args_to_terms XS R.
args_to_terms [] [].

pred construct_cuts_args i: (list argument), o: term.
construct_cuts_args L1 R :- args_to_terms L1 L1', construct_cuts L1' R.

% dummy predicate to work with multiple subgoals which are all proved by I
pred refine_list_of_true i: list sealed-goal, o: list sealed-goal. 
    refine_list_of_true [G] [G] :- !.
    refine_list_of_true [G1|GL1] GL3 :- !, std.last GL1 G, coq.ltac.open (refine {{I}}) G GL2, 
        refine_list_of_true [G1|GL2] GL3.
    refine_list_of_true [] [].

pred find_in_context i: term, i: goal-ctx, o: term.
    find_in_context Trm [decl Var _ Ty| XS] Var :- coq.unify-eq Trm Ty ok.
    find_in_context Trm [X | XS] Var :- find_in_context Trm XS Var.
    find_in_context Trm [] _ :- coq.error "not in the context".

pred refine_by_app i: term, i: goal, o: list sealed-goal.
    refine_by_app Ty (goal Ctx _ _ _ _ as G) GL :- find_in_context Ty Ctx Trm, refine (app [Trm, _]) G GL. 

pred refine_by_instantiation i: list sealed-goal, i: (pair term term), o: list sealed-goal.
    % refine_by_instanciation GL1 P GL2 proofs all the subgoals except the first one by applying the theorem fst P (or its equivalent found in the context)
    refine_by_instanciation [G] _ [G] :- !.
    refine_by_instanciation [G1|GL1] P GL3 :- fst P T, std.last GL1 G,
     coq.ltac.open (refine (app [T, _])) G GL2, !,
        refine_by_instanciation [G1|GL2] P GL3.
        refine_by_instanciation [G1|GL1] P GL3 :- !, snd P Ty, std.last GL1 G,
     coq.ltac.open (refine_by_app T) G GL2, 
        refine_by_instanciation [G1|GL2] P GL3.
    refine_by_instanciation [] _ [].